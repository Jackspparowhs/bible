<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Global Flight Tracker — PirateRuler.com</title>
<link rel="icon" href="https://pirateruler.com/static/pr-logo.png" type="image/png">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<style>
  html,body,#map{height:100%;margin:0;padding:0}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#071225; color:#e9f1ff}
  .topbar{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:linear-gradient(90deg, rgba(6,16,40,0.9), rgba(7,18,37,0.9));color:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.45);position:relative;z-index:1000;gap:12px;}
  .brand{display:flex;align-items:center;gap:10px}
  .logo{width:40px;height:40px;border-radius:10px;background:linear-gradient(135deg,#6bbf4a,#2fa64f);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:14px;color:#06221a;box-shadow:0 6px 18px rgba(0,0,0,0.35);}
  .controls{display:flex;gap:8px;align-items:center}
  .search{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;}
  input[type="search"]{background:transparent;border:0;color:#fff;outline:0;padding:6px 8px;font-size:14px;width:220px}
  .btn{cursor:pointer;border:0;padding:8px 10px;border-radius:8px;background:linear-gradient(90deg,#6bbf4a,#2fa64f);color:#fff;font-weight:800;font-size:13px}
  #map{position:absolute;top:56px;bottom:0;left:0;right:0}
  .status{position:absolute;right:12px;bottom:12px;z-index:1000;background:rgba(0,0,0,0.45);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;pointer-events:none;opacity:0.95}
  .legend{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.35);color:#fff;padding:6px 8px;border-radius:8px;z-index:1000;font-size:13px}
  @media(max-width:560px){ input[type="search"]{width:140px} .topbar{padding:8px} #map{top:52px} }
  .popup-title{font-weight:900;margin-bottom:6px}
  .small-muted{font-size:13px;color:#ddd}
</style>
</head>
<body>
  <div class="topbar" role="navigation" aria-label="Map controls">
    <div class="brand">
      <div class="logo" title="PirateRuler">PR</div>
    </div>

    <div class="controls" role="search" aria-label="Map search">
      <div class="search" title="Filter flights">
        <input id="filterInput" type="search" placeholder="Filter by callsign / reg / icao24" aria-label="Filter">
        <button id="filterBtn" class="btn">Filter</button>
      </div>
      <a href="/" class="btn" style="background:transparent;border:1px solid rgba(255,255,255,0.07);color:#fff;font-weight:800;padding:8px 10px;border-radius:8px">Home</a>
    </div>
  </div>

  <div id="map" role="application" aria-label="Flight map"></div>

  <div class="legend">Leaflet | © OpenStreetMap contributors</div>
  <div id="status" class="status" aria-live="polite">Initializing…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
/* ====== GLOBAL / WHOLE-WORLD LOADER ======
   Notes (READ):
   - For reliable global data, run a server proxy (see Proxy snippet at bottom).
   - This page splits the whole world into tiles and fetches each tile sequentially.
   - This is heavy: expect many requests and thousands of markers; tune TILE_ROWS/TILE_COLS and MAX_TOTAL_MARKERS.
*/

/* ========== CONFIG ========== */
const PROXY_URL = ''; // set to your proxy endpoint (recommended), e.g. 'https://your-vps.com/opensky'
const DIRECT_OPENSKY = true; // if PROXY_URL empty, try direct OpenSky (likely CORS-blocked)
const TILE_ROWS = 12;    // increase for smaller tiles (more requests). 12 rows x TILE_COLS cols.
const TILE_COLS = 24;    // 24 cols => 288 tiles. Tune down if too slow.
const TILE_FETCH_DELAY = 200; // ms delay between tile requests
const BATCH_SIZE = 300;  // markers per batch when rendering
const MAX_TOTAL_MARKERS = 12000; // safety cap to avoid browser OOM
const POLL_INTERVAL_MS = 60000; // how often to refresh whole-world (set high to avoid rate limits)

/* Whole-world bounding box */
const WORLD_BBOX = {
  lamin: -90, lomin: -180,
  lamax:  90, lomax:  180
};

/* ========== MAP SETUP ========== */
const map = L.map('map', { zoomControl: true }).setView([20, 0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

const clusterGroup = L.markerClusterGroup({ chunkedLoading: true, maxClusterRadius: 60, disableClusteringAtZoom: 12 });
clusterGroup.addTo(map);

const statusEl = document.getElementById('status');
const filterInput = document.getElementById('filterInput');
document.getElementById('filterBtn').addEventListener('click', applyFilter);
filterInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') applyFilter(); });

/* fallback demo */
const demoAircraft = [
  { icao24:'demo1', reg:'G-ABCD', callsign:'BAW123', lat:51.5, lon:-0.12, alt:35000, hdg:90, source:'demo' },
  { icao24:'demo2', reg:'N12345', callsign:'DAL456', lat:41.9, lon:12.5, alt:28000, hdg:45, source:'demo' },
  { icao24:'demo3', reg:'A6-XYZ', callsign:'UAE789', lat:30.4, lon:31.2, alt:32000, hdg:270, source:'demo' }
];

/* state */
let aircraftByIcao = {};
let renderQueue = [];
let fetching = false;

/* helpers */
function escapeHtml(str){ return String(str || '').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); }
function aircraftIcon(hdg){ return L.divIcon({ html: `<div style="transform:rotate(${hdg||0}deg);font-size:18px;line-height:0">✈️</div>`, className: '' }); }

/* enqueue + render in batches to avoid freeze */
function enqueueAndRender(items){
  let added = 0;
  items.forEach(a => {
    if(!a || !a.icao24) return;
    if(aircraftByIcao[a.icao24]) {
      // update existing (position may change)
      aircraftByIcao[a.icao24] = { ...aircraftByIcao[a.icao24], ...a };
      return;
    }
    aircraftByIcao[a.icao24] = a;
    renderQueue.push(a);
    added++;
  });
  if(added) processRenderQueue();
}

let processing = false;
function processRenderQueue(){
  if(processing) return;
  processing = true;
  (function step(){
    const chunk = renderQueue.splice(0, BATCH_SIZE);
    if(chunk.length){
      const markers = chunk.map(a => {
        const m = L.marker([a.lat, a.lon], { icon: aircraftIcon(a.hdg || 0) });
        const popup = `<div class="popup-title">${escapeHtml(a.callsign||'—')} — ${escapeHtml(a.reg||a.icao24||'')}</div>
          <div class="small-muted">Alt: ${a.alt !== null && a.alt !== undefined ? (Math.round(a.alt) + ' ft') : 'N/A'}<br>
            Heading: ${a.hdg !== null && a.hdg !== undefined ? Math.round(a.hdg) + '°' : 'N/A'}<br>
            Source: ${escapeHtml(a.source || 'unknown')}</div>`;
        m.bindPopup(popup);
        return m;
      });
      clusterGroup.addLayers(markers);
      setTimeout(step, 60);
    } else {
      processing = false;
      statusEl.textContent = `Rendered ${Object.keys(aircraftByIcao).length} aircraft`;
      if(Object.keys(aircraftByIcao).length > MAX_TOTAL_MARKERS) statusEl.textContent += ' (cap reached)';
    }
  })();
}

/* build fetch URL */
function buildFetchUrl(params){
  const q = Object.entries(params).map(([k,v]) => `${k}=${encodeURIComponent(v)}`).join('&');
  if(PROXY_URL && PROXY_URL.length){
    return `${PROXY_URL}?${q}`;
  } else {
    return `https://opensky-network.org/api/states/all?${q}`;
  }
}

/* parse OpenSky */
function parseOpenSkyStates(data){
  if(!data || !Array.isArray(data.states)) return [];
  return data.states.map(s => ({
    icao24: s[0],
    callsign: (s[1] || '').trim(),
    origin_country: s[2],
    time_position: s[3],
    last_contact: s[4],
    lon: s[5],
    lat: s[6],
    alt_baro: s[7],
    on_ground: s[8],
    velocity: s[9],
    hdg: s[10],
    vert_rate: s[11],
    source: 'OpenSky'
  })).filter(x => x.lat !== null && x.lon !== null).map(a => ({
    icao24: a.icao24,
    reg: a.icao24,
    callsign: a.callsign || a.icao24,
    lat: a.lat,
    lon: a.lon,
    alt: (a.alt_baro !== null && a.alt_baro !== undefined) ? Math.round(a.alt_baro * 3.28084) : null,
    hdg: a.hdg || 0,
    source: a.source
  }));
}

/* generate world tiles */
function generateTiles(rows, cols, bbox){
  const tiles = [];
  const latStep = (bbox.lamax - bbox.lamin) / rows;
  const lonStep = (bbox.lomax - bbox.lomin) / cols;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const lamin = bbox.lamin + (r * latStep);
      const lamax = bbox.lamin + ((r+1) * latStep);
      const lomin = bbox.lomin + (c * lonStep);
      const lomax = bbox.lomin + ((c+1) * lonStep);
      tiles.push({ lamin, lomin, lamax, lomax });
    }
  }
  return tiles;
}

/* fetch tiles sequentially and add results progressively */
async function fetchAllTilesAndRender(){
  if(fetching) return;
  fetching = true;
  statusEl.textContent = 'Preparing world tiles…';
  const tiles = generateTiles(TILE_ROWS, TILE_COLS, WORLD_BBOX);
  statusEl.textContent = `Fetching ${tiles.length} tiles (this will take time)…`;

  for(let i=0;i<tiles.length;i++){
    if(Object.keys(aircraftByIcao).length >= MAX_TOTAL_MARKERS){
      statusEl.textContent = `Marker cap reached (${MAX_TOTAL_MARKERS}). Stopping further fetches.`;
      break;
    }
    const t = tiles[i];
    const url = buildFetchUrl({ lamin: t.lamin, lomin: t.lomin, lamax: t.lamax, lomax: t.lomax });
    try {
      statusEl.textContent = `Fetching tile ${i+1}/${tiles.length}…`;
      const resp = await fetch(url, { cache: 'no-store' });
      if(!resp.ok) throw new Error('HTTP ' + resp.status);
      const json = await resp.json();
      const parsed = parseOpenSkyStates(json);
      enqueueAndRender(parsed);
    } catch(err){
      console.warn('Tile fetch failed:', err);
      // If first tile fails (likely CORS), fallback to demo and stop
      if(i === 0){
        statusEl.textContent = 'Live fetch blocked (CORS or network). Showing demo. For full live data use server proxy.';
        enqueueAndRender(demoAircraft);
        fetching = false;
        return;
      } else {
        // continue to next tile
        statusEl.textContent = `Tile ${i+1} failed — continuing…`;
      }
    }
    await new Promise(res => setTimeout(res, TILE_FETCH_DELAY));
  }

  statusEl.textContent = `Load finished — ${Object.keys(aircraftByIcao).length} unique aircraft (may be partial).`;
  fetching = false;
}

/* filter & rebuild functions */
function applyFilter(){
  const q = filterInput.value.trim().toLowerCase();
  if(!q){
    rebuildClustersFromState();
    return;
  }
  const values = Object.values(aircraftByIcao).filter(a => ((a.reg||'') + ' ' + (a.callsign||'') + ' ' + (a.icao24||'')).toLowerCase().includes(q));
  clusterGroup.clearLayers();
  const markers = values.map(a => {
    const m = L.marker([a.lat, a.lon], { icon: aircraftIcon(a.hdg || 0) });
    m.bindPopup(`<div class="popup-title">${escapeHtml(a.callsign||'—')} — ${escapeHtml(a.reg||a.icao24||'')}</div>
      <div class="small-muted">Alt: ${a.alt || 'N/A'} ft<br>Heading: ${a.hdg || 'N/A'}°<br>Source: ${escapeHtml(a.source||'unknown')}</div>`);
    return m;
  });
  clusterGroup.addLayers(markers);
  if(values.length) map.setView([values[0].lat, values[0].lon], 5);
  statusEl.textContent = `Filter: ${values.length} matches`;
}

function rebuildClustersFromState(){
  clusterGroup.clearLayers();
  const all = Object.values(aircraftByIcao).slice(0, MAX_TOTAL_MARKERS);
  const markers = all.map(a => {
    const m = L.marker([a.lat, a.lon], { icon: aircraftIcon(a.hdg || 0) });
    m.bindPopup(`<div class="popup-title">${escapeHtml(a.callsign||'—')} — ${escapeHtml(a.reg||a.icao24||'')}</div>
      <div class="small-muted">Alt: ${a.alt || 'N/A'} ft<br>Heading: ${a.hdg || 'N/A'}°<br>Source: ${escapeHtml(a.source||'unknown')}</div>`);
    return m;
  });
  clusterGroup.addLayers(markers);
  statusEl.textContent = `Showing ${all.length} aircraft`;
}

/* manual reload in console */
window.reloadAllAircraft = async function(){
  aircraftByIcao = {};
  renderQueue = [];
  clusterGroup.clearLayers();
  await fetchAllTilesAndRender();
};

/* start initial load */
(async function start(){
  enqueueAndRender(demoAircraft); // immediate visual
  statusEl.textContent = 'Starting world fetch (may take several minutes)…';
  await fetchAllTilesAndRender();

  // periodic refresh (be careful with rate limits)
  setInterval(async ()=>{
    aircraftByIcao = {}; renderQueue = []; clusterGroup.clearLayers();
    await fetchAllTilesAndRender();
  }, POLL_INTERVAL_MS);
})();

/* ====== Proxy snippet (recommended) ======
If browser CORS blocks OpenSky, run this on your VPS (node 16+).
Save as proxy.js and run `node proxy.js`. Use PROXY_URL = 'https://your-vps.example/opensky' in config above.

------------------------------------------------
import express from 'express';
import fetch from 'node-fetch';
const app = express();
let cache = { ts:0, body:null };
app.get('/opensky', async (req, res) => {
  const { lamin='-90', lomin='-180', lamax='90', lomax='180' } = req.query;
  // simple cache: 12s
  if(Date.now() - cache.ts < 12000 && cache.body){
    res.set('Content-Type','application/json'); return res.send(cache.body);
  }
  try {
    const url = `https://opensky-network.org/api/states/all?lamin=${lamin}&lomin=${lomin}&lamax=${lamax}&lomax=${lomax}`;
    const r = await fetch(url);
    const text = await r.text();
    cache = { ts: Date.now(), body: text };
    res.set('Content-Type','application/json'); res.send(text);
  } catch(err){
    console.error(err);
    res.status(502).send({error:'fetch failed'});
  }
});
app.listen(3000, ()=>console.log('proxy listening 3000'));
------------------------------------------------

Then set PROXY_URL to 'https://your-vps.example:3000/opensky' (or the full https URL) and reload the page.

*/

/* ====== FINAL NOTES ======
1) This tries to fetch the entire world. It will issue many requests (TILE_ROWS x TILE_COLS). If you see slow or partial results:
   - set PROXY_URL to your proxy (recommended)
   - reduce TILE_ROWS/COLS (fewer tiles)
   - reduce MAX_TOTAL_MARKERS
2) Better approach: viewport-based loading (fetch for map bounds on moveend). Faster and lighter. Tell me "viewport mode" if you want that.
3) If you need the proxy deployed, say which VPS provider you use and I’ll give exact steps (or I can paste a docker-friendly proxy file).

Paste this file on your server and test. Tell me what you see (how many markers, if you get CORS errors in console). I’ll adjust values (tiles, batches, caps) to match your device.
