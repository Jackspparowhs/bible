<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flight Tracker Map — PirateRuler.com</title>
<link rel="icon" href="https://pirateruler.com/static/pr-logo.png" type="image/png">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<style>
  html,body,#map{height:100%;margin:0;padding:0}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#071225; color:#e9f1ff}
  .topbar{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:linear-gradient(90deg, rgba(6,16,40,0.9), rgba(7,18,37,0.9));color:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.45);position:relative;z-index:1000;gap:12px;}
  .brand{display:flex;align-items:center;gap:10px}
  .logo{width:40px;height:40px;border-radius:10px;background:linear-gradient(135deg,#6bbf4a,#2fa64f);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:14px;color:#06221a;box-shadow:0 6px 18px rgba(0,0,0,0.35);}
  .controls{display:flex;gap:8px;align-items:center}
  .search{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;}
  input[type="search"]{background:transparent;border:0;color:#fff;outline:0;padding:6px 8px;font-size:14px;width:220px}
  .btn{cursor:pointer;border:0;padding:8px 10px;border-radius:8px;background:linear-gradient(90deg,#6bbf4a,#2fa64f);color:#fff;font-weight:800;font-size:13px}
  #map{position:absolute;top:56px;bottom:0;left:0;right:0}
  .status{position:absolute;right:12px;bottom:12px;z-index:1000;background:rgba(0,0,0,0.45);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;pointer-events:none;opacity:0.95}
  .legend{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.35);color:#fff;padding:6px 8px;border-radius:8px;z-index:1000;font-size:13px}
  @media(max-width:560px){ input[type="search"]{width:140px} .topbar{padding:8px} #map{top:52px} }
  .popup-title{font-weight:900;margin-bottom:6px}
  .small-muted{font-size:13px;color:#ddd}
</style>
</head>
<body>
  <div class="topbar" role="navigation" aria-label="Map controls">
    <div class="brand">
      <div class="logo" title="PirateRuler">PR</div>
    </div>

    <div class="controls" role="search" aria-label="Map search">
      <div class="search" title="Filter flights">
        <input id="filterInput" type="search" placeholder="Filter by callsign / reg / icao24" aria-label="Filter">
        <button id="filterBtn" class="btn">Filter</button>
      </div>
      <a href="/" class="btn" style="background:transparent;border:1px solid rgba(255,255,255,0.07);color:#fff;font-weight:800;padding:8px 10px;border-radius:8px">Home</a>
    </div>
  </div>

  <div id="map" role="application" aria-label="Flight map"></div>

  <div class="legend">Leaflet | © OpenStreetMap contributors</div>
  <div id="status" class="status" aria-live="polite">Initializing…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
/* === CONFIG ===
   PROXY_URL: set to your server proxy if you run one (recommended).
   If left empty, client will attempt direct ADSBExchange -> OpenSky -> AllOrigins fallbacks.
*/
const PROXY_URL = ''; // e.g. 'https://your-vps.example/opensky' or proxy that forwards requests
const TILE_ROWS = 8;         // tune for performance (rows x cols tiles)
const TILE_COLS = 16;
const TILE_FETCH_DELAY = 250;
const BATCH_SIZE = 250;
const MAX_TOTAL_MARKERS = 10000;
const WORLD_BBOX = { lamin:-90, lomin:-180, lamax:90, lomax:180 };
const POLL_INTERVAL_MS = 120000; // refresh interval

/* === MAP & UI (unchanged visually) === */
const map = L.map('map', { zoomControl: true }).setView([20, 0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

const clusterGroup = L.markerClusterGroup({ chunkedLoading: true, maxClusterRadius: 60, disableClusteringAtZoom: 12 });
clusterGroup.addTo(map);

const statusEl = document.getElementById('status');
const filterInput = document.getElementById('filterInput');
document.getElementById('filterBtn').addEventListener('click', applyFilter);
filterInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') applyFilter(); });

/* demo fallback */
const demoAircraft = [
  { icao24:'demo1', reg:'G-ABCD', callsign:'BAW123', lat:51.5, lon:-0.12, alt:35000, hdg:90, source:'demo' },
  { icao24:'demo2', reg:'N12345', callsign:'DAL456', lat:41.9, lon:12.5, alt:28000, hdg:45, source:'demo' },
  { icao24:'demo3', reg:'A6-XYZ', callsign:'UAE789', lat:30.4, lon:31.2, alt:32000, hdg:270, source:'demo' }
];

/* state */
let aircraftByIcao = {};
let renderQueue = [];
let fetching = false;

/* helpers */
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }
function aircraftIcon(hdg){ return L.divIcon({ html: `<div style="transform:rotate(${hdg||0}deg);font-size:18px;line-height:0">✈️</div>`, className: '' }); }

/* enqueue + progressive render */
function enqueueAndRender(items){
  let added = 0;
  items.forEach(a=>{
    if(!a || !a.icao24) return;
    if(aircraftByIcao[a.icao24]){
      aircraftByIcao[a.icao24] = { ...aircraftByIcao[a.icao24], ...a };
      return;
    }
    aircraftByIcao[a.icao24] = a;
    renderQueue.push(a);
    added++;
  });
  if(added) processRenderQueue();
}

let processing = false;
function processRenderQueue(){
  if(processing) return;
  processing = true;
  (function step(){
    const chunk = renderQueue.splice(0, BATCH_SIZE);
    if(chunk.length){
      const markers = chunk.map(a=>{
        const m = L.marker([a.lat, a.lon], { icon: aircraftIcon(a.hdg || 0) });
        const popup = `<div class="popup-title">${escapeHtml(a.callsign||'—')} — ${escapeHtml(a.reg||a.icao24||'')}</div>
          <div class="small-muted">Alt: ${a.alt !== null && a.alt !== undefined ? (Math.round(a.alt) + ' ft') : 'N/A'}<br>
            Heading: ${a.hdg !== null && a.hdg !== undefined ? Math.round(a.hdg) + '°' : 'N/A'}<br>
            Source: ${escapeHtml(a.source || 'unknown')}</div>`;
        m.bindPopup(popup);
        return m;
      });
      clusterGroup.addLayers(markers);
      setTimeout(step, 60);
    } else {
      processing = false;
      statusEl.textContent = `Rendered ${Object.keys(aircraftByIcao).length} aircraft`;
      if(Object.keys(aircraftByIcao).length > MAX_TOTAL_MARKERS) statusEl.textContent += ' (cap reached)';
    }
  })();
}

/* rebuild clusters (filter reset) */
function rebuildClustersFromState(){
  clusterGroup.clearLayers();
  const all = Object.values(aircraftByIcao).slice(0, MAX_TOTAL_MARKERS);
  const markers = all.map(a=>{
    const m = L.marker([a.lat, a.lon], { icon: aircraftIcon(a.hdg || 0) });
    m.bindPopup(`<div class="popup-title">${escapeHtml(a.callsign||'—')} — ${escapeHtml(a.reg||a.icao24||'')}</div>
      <div class="small-muted">Alt: ${a.alt || 'N/A'} ft<br>Heading: ${a.hdg || 'N/A'}°<br>Source: ${escapeHtml(a.source||'unknown')}</div>`);
    return m;
  });
  clusterGroup.addLayers(markers);
  statusEl.textContent = `Showing ${all.length} aircraft`;
}

/* filter */
function applyFilter(){
  const q = filterInput.value.trim().toLowerCase();
  if(!q){ rebuildClustersFromState(); return; }
  const values = Object.values(aircraftByIcao).filter(a => ((a.reg||'') + ' ' + (a.callsign||'') + ' ' + (a.icao24||'')).toLowerCase().includes(q));
  clusterGroup.clearLayers();
  const markers = values.map(a=>{
    const m = L.marker([a.lat, a.lon], { icon: aircraftIcon(a.hdg || 0) });
    m.bindPopup(`<div class="popup-title">${escapeHtml(a.callsign||'—')} — ${escapeHtml(a.reg||a.icao24||'')}</div>
      <div class="small-muted">Alt: ${a.alt || 'N/A'} ft<br>Heading: ${a.hdg || 'N/A'}°<br>Source: ${escapeHtml(a.source||'unknown')}</div>`);
    return m;
  });
  clusterGroup.addLayers(markers);
  if(values.length) map.setView([values[0].lat, values[0].lon], 4);
  statusEl.textContent = `Filter: ${values.length} matches`;
}

/* ---------- API helpers ---------- */

/* Compute center & radius (nautical miles) for a tile */
function tileCenterAndRadius(tile){
  const latC = (tile.lamin + tile.lamax) / 2;
  const lonC = (tile.lomin + tile.lomax) / 2;
  // approximate half-diagonal in km (1 deg lat ~=111 km, lon scaled by cos(lat))
  const latSpan = Math.abs(tile.lamax - tile.lamin);
  const lonSpan = Math.abs(tile.lomax - tile.lomin);
  const latKm = latSpan * 111;
  const lonKm = lonSpan * 111 * Math.cos(latC * Math.PI/180);
  const halfDiagKm = Math.sqrt((latKm/2)**2 + (lonKm/2)**2);
  const nm = Math.max(10, Math.round(halfDiagKm / 1.852)); // convert km to nautical miles; min 10nm
  return { lat: latC, lon: lonC, nm };
}

/* ADSBExchange endpoint (by center+radius)
   Example: https://adsbexchange.com/api/aircraft/lat/51.5005/lon/-0.1145/dist/100/
   NOTE: heavy use may require api-auth header or an enterprise plan.
*/
function buildADSBUrl(lat, lon, nm){
  return `https://adsbexchange.com/api/aircraft/lat/${encodeURIComponent(lat)}/lon/${encodeURIComponent(lon)}/dist/${encodeURIComponent(nm)}/`;
}

/* OpenSky bounding box fallback url */
function buildOpenSkyUrl(lamin, lomin, lamax, lomax){
  return `https://opensky-network.org/api/states/all?lamin=${lamin}&lomin=${lomin}&lamax=${lamax}&lomax=${lomax}`;
}

/* AllOrigins wrapper for CORS fallback */
function allOriginsRaw(url){
  return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
}

/* Parse ADSBExchange JSON (their /api/aircraft returns an object with 'ac' array) */
function parseADSBResponse(json){
  // ADSBExchange 'ac' array items contain fields like 'lat','lon','flight' (callsign), 'hex' (icao24), 'altitude', 'track'
  if(!json) return [];
  const arr = json.ac || json.aircraft || [];
  return arr.map(a => ({
    icao24: a.hex || a.icao || (a.modeS ? a.modeS : null) || (a.modeSHex ? a.modeSHex : null) || (a.icao24 ? a.icao24 : null),
    reg: a.reg || a.registration || a.r || '' ,
    callsign: (a.flight || a.call || a.callsign || a.flightId || '') .toString().trim(),
    lat: a.lat || a.latitude || a['lat'],
    lon: a.lon || a.longitude || a['lon'],
    alt: a.alt || a.altitude || a.geoalt || null,
    hdg: a.track || a.heading || a.hdg || 0,
    source: 'ADSBExchange'
  })).filter(x => x.lat !== null && x.lon !== null);
}

/* Parse OpenSky */
function parseOpenSkyStates(data){
  if(!data || !Array.isArray(data.states)) return [];
  return data.states.map(s=>({
    icao24: s[0],
    callsign: (s[1] || '').trim(),
    lon: s[5],
    lat: s[6],
    alt: (s[7] !== null && s[7] !== undefined) ? Math.round(s[7] * 3.28084) : null,
    hdg: s[10] || 0,
    source: 'OpenSky'
  })).filter(x => x.lat !== null && x.lon !== null);
}

/* Try ADSBExchange -> OpenSky -> AllOrigins for each tile */
async function fetchTileData(tile){
  const { lat, lon, nm } = tileCenterAndRadius(tile);
  // 1) ADSBExchange direct (fast if allowed)
  try {
    let url = buildADSBUrl(lat, lon, nm);
    if(PROXY_URL) url = `${PROXY_URL}?proxysrc=${encodeURIComponent(url)}`; // optional proxy pattern (see proxy notes)
    statusEl.textContent = `ADSBExchange: ${lat.toFixed(2)},${lon.toFixed(2)} / ${nm}nm`;
    const resp = await fetch(url, { cache:'no-store' , headers: PROXY_URL ? {} : {} });
    if(resp.ok){
      const json = await resp.json();
      const parsed = parseADSBResponse(json);
      if(parsed && parsed.length) return parsed;
      // if ADSBExchange returned empty, we still try OpenSky below
    } else {
      // if blocked (403/401), continue to fallback
      console.warn('ADSBExchange status', resp.status);
    }
  } catch(err){
    console.warn('ADSBExchange fetch failed:', err);
  }

  // 2) OpenSky bbox fallback (tile bbox)
  try {
    const urlOpen = buildOpenSkyUrl(tile.lamin, tile.lomin, tile.lamax, tile.lomax);
    let finalUrl = urlOpen;
    if(PROXY_URL){
      finalUrl = `${PROXY_URL}?proxysrc=${encodeURIComponent(urlOpen)}`;
    }
    statusEl.textContent = `OpenSky: ${tile.lamin.toFixed(1)},${tile.lomin.toFixed(1)} → ${tile.lamax.toFixed(1)},${tile.lomax.toFixed(1)}`;
    const r2 = await fetch(finalUrl, { cache:'no-store' });
    if(r2.ok){
      const j2 = await r2.json();
      const parsed2 = parseOpenSkyStates(j2);
      if(parsed2 && parsed2.length) return parsed2;
    } else {
      console.warn('OpenSky status', r2.status);
    }
  } catch(err){
    console.warn('OpenSky fetch failed:', err);
  }

  // 3) As last resort try CORS proxy (AllOrigins) wrapping OpenSky
  try {
    const urlOpen = buildOpenSkyUrl(tile.lamin, tile.lomin, tile.lamax, tile.lomax);
    const corsUrl = allOriginsRaw(urlOpen);
    statusEl.textContent = `CORS-proxy: ${tile.lamin.toFixed(1)},${tile.lomin.toFixed(1)}`;
    const r3 = await fetch(corsUrl, { cache:'no-store' });
    if(r3.ok){
      const j3 = await r3.json();
      const parsed3 = parseOpenSkyStates(j3);
      if(parsed3 && parsed3.length) return parsed3;
    } else {
      console.warn('AllOrigins status', r3.status);
    }
  } catch(err){
    console.warn('AllOrigins failed:', err);
  }

  // nothing worked
  return null;
}

/* tile generation */
function generateTiles(rows, cols, bbox){
  const tiles = [];
  const latStep = (bbox.lamax - bbox.lamin) / rows;
  const lonStep = (bbox.lomax - bbox.lomin) / cols;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const lamin = bbox.lamin + (r * latStep);
      const lamax = bbox.lamin + ((r+1) * latStep);
      const lomin = bbox.lomin + (c * lonStep);
      const lomax = bbox.lomin + ((c+1) * lonStep);
      tiles.push({ lamin, lomin, lamax, lomax });
    }
  }
  return tiles;
}

/* main tile fetcher - sequential with delay */
async function fetchAllTilesAndRender(){
  if(fetching) return;
  fetching = true;
  statusEl.textContent = 'Preparing tiles…';
  const tiles = generateTiles(TILE_ROWS, TILE_COLS, WORLD_BBOX);
  statusEl.textContent = `Fetching ${tiles.length} tiles… (this may take a while)`;

  for(let i=0;i<tiles.length;i++){
    if(Object.keys(aircraftByIcao).length >= MAX_TOTAL_MARKERS){
      statusEl.textContent = `Reached cap (${MAX_TOTAL_MARKERS}). Stopping...`;
      break;
    }
    const tile = tiles[i];
    statusEl.textContent = `Fetching tile ${i+1}/${tiles.length}...`;
    const parsed = await fetchTileData(tile);
    if(parsed === null){
      // fallback: if first tile fails, show demo and stop to avoid long waits.
      if(i === 0){
        statusEl.textContent = 'Live fetch blocked. Showing demo. (Run proxy for real live data)';
        enqueueAndRender(demoAircraft);
        fetching = false;
        return;
      } else {
        statusEl.textContent = `Tile ${i+1} failed — continuing`;
      }
    } else if(parsed.length){
      // normalize parsed items into our format (some from ADSB already match)
      const mapped = parsed.map(a => ({
        icao24: (a.icao24 || a.hex || a.icao || '').toLowerCase(),
        reg: a.reg || a.registration || a.reg || '',
        callsign: (a.callsign || a.flight || '').toString().trim(),
        lat: a.lat,
        lon: a.lon,
        alt: a.alt || null,
        hdg: a.hdg || 0,
        source: a.source || 'api'
      }));
      enqueueAndRender(mapped);
    }
    await new Promise(res => setTimeout(res, TILE_FETCH_DELAY));
  }

  statusEl.textContent = `Tile load complete — ${Object.keys(aircraftByIcao).length} unique aircraft (may be partial)`;
  fetching = false;
}

/* expose manual reload */
window.reloadAllAircraft = async function(){
  aircraftByIcao = {};
  renderQueue = [];
  clusterGroup.clearLayers();
  await fetchAllTilesAndRender();
};

/* start */
(async function init(){
  enqueueAndRender(demoAircraft);
  statusEl.textContent = 'Starting world fetch (ADSBExchange preferred)…';
  await fetchAllTilesAndRender();
  setInterval(async ()=>{
    aircraftByIcao = {}; renderQueue = []; clusterGroup.clearLayers();
    await fetchAllTilesAndRender();
  }, POLL_INTERVAL_MS);
})();

/* ====== Recommended tiny proxy (if you need reliable live data) ======
Save as proxy.js on your VPS (node 16+). It forwards any proxysrc= URL.
Run: node proxy.js  (use a proper process manager / HTTPS in production)

------------------------------------------
import express from 'express';
import fetch from 'node-fetch';
const app = express();
let cache = { ts:0, bodyMap: {} };

// simple endpoint: /proxy?proxysrc={encodeURIComponent(originalUrl)}
app.get('/proxy', async (req, res) => {
  const src = req.query.proxysrc;
  if(!src) return res.status(400).send('missing proxysrc');
  // simple per-URL cache for 10s
  if(cache.bodyMap[src] && (Date.now() - cache.bodyMap[src].ts < 10000)) {
    res.set('Content-Type','application/json');
    return res.send(cache.bodyMap[src].body);
  }
  try {
    const r = await fetch(src);
    const txt = await r.text();
    cache.bodyMap[src] = { ts: Date.now(), body: txt };
    res.set('Content-Type','application/json');
    res.send(txt);
  } catch(e){
    console.error('proxy fetch failed', e);
    res.status(502).send({ error: 'proxy fetch failed' });
  }
});
app.listen(3000, ()=>console.log('proxy listening 3000'));
------------------------------------------

If you run the proxy, set `PROXY_URL = 'https://your-vps.example/proxy'` at top of this file.
*/

  </script>
</body>
</html>
